#ifndef __CALIBRATION_WIZARD_H__
#define __CALIBRATION_WIZARD_H__

#include <QChart>
#include <QGroupBox>
#include <QJsonObject>
#include <QLabel>
#include <QLayout>
#include <QObject>
#include <QPushButton>
#include <QStateMachine>
#include <QTableWidget>
#include <QTextBrowser>
#include <QtCharts>

// XXX: with MSVC2015 compilation fails if #include "ControlGroupBox.h" is declared before #include <QChart>
#include "CalibrationStateMachine.h"
#include "ControlGroupBox.h"
#include "GrabbingGroupBox.h"
#include "Htt.h"
#include "HwController.h"
#include "ModalityWork.h"

using namespace std;
using namespace Nidek::Libraries::HTT;
using namespace Nidek::Solution::HTT::UserApplication;

namespace Nidek {
namespace Solution {
namespace HTT {
namespace UserApplication {

class CalibrationWizard : public QObject
{
    Q_OBJECT
public:
    // FIXME
    explicit CalibrationWizard(ControlGroupBox* controlsGroupBox, GrabbingGroupBox* grabbingGroupBox,
                               shared_ptr<HwController> hwController, QObject* parent = nullptr);
    ~CalibrationWizard();
    void start();
    void stop();
    void resume();

private:
    void initStateMachine();

    void loadJsonState();
    void saveJsonState();
    void enteredIdle();
    void exitedIdle();
    void enteredStep1();
    void exitedStep1();
    void enteredStep2();
    void exitedStep2();
    void enteredStep3();
    void exitedStep3();
    void enteredStep4();
    void exitedStep4();
    void enteredStep5();
    void exitedStep5();
    void enteredStep6();
    void exitedStep6();
    void enteredStep7();
    void exitedStep7();
    void enteredStep8();
    void exitedStep8();
    void enteredStep9();
    void exitedStep9();
    void enteredStep10();
    void exitedStep10();
    void enteredDone();
    void finishedDone();

    void visualizeHttLightOutputFluxTable();
    void removeHttLightOutputFluxTable();
    void removeCalibrationTableResults();

signals:
    void doVisualizeFrame(QSharedPointer<QImage> image);
    void doVisualizeCalibrationResults(vector<pair<pair<int, int>, pair<int, int>>> imgLines,
                                       vector<pair<int, int>> imgPoints, QSharedPointer<QImage> objPlaneGrid,
                                       vector<pair<int, int>> objPoints);
    void doVisualizeImagingFoV(QSharedPointer<QImage> objPlaneGrid, vector<pair<int, int>> objPoints);
    void doStartGridCalibration(QSharedPointer<QImage> image);
    void doStartAccurateCalibration(QSharedPointer<QImage> frame, const double& deltaN, const double& H);
    void doValidateGridCalibration(vector<float> gridErrors);
    void doValidateAccurateCalibration(Htt::LensFittingResults res);
    void doEnableStartCalibrationButton();
    void doSetViewerModality(Modality mod);
    void updateStatusBar(QString str);
    void progressBackButtonClicked();
    // Require a screenshot and a frame image to ImageViewerController and wait screeshotReady and/or frameReady events
    void doTakeScreenshot();
    void doVisualizeChart(QChart* chart);
    void doUpdateChart(QLineSeries* series);
    void doStartLensFitting(QSharedPointer<QImage> image, double deltaN, double H, ModelType modelType);
    void doDetectProfile(QSharedPointer<QImage> image, double deltaN, double H, ModelType modelType);
    void doVisualizeLensFittingResults(Htt::LensFittingResults res);
    void doVisualizeProfileDetectionResults(Htt::ProfileDetectionResults res);
    void doCalibrationDone(bool reportSaved);
    void doResetImageViewerController();
    void doVisualizeSlicingConstrastLines(const QPointF& p1, const QPointF& p2, const QPointF& p3, const QPointF& p4);

private slots:
    void pushButtonClickedStartWizard(bool);
    void pushButtonClickedResumeWizard(bool);
    void pushButtonClickedProgressBack(bool);
    void calibrationGridResultsReady(Htt::CalibrationGridResults result);
    void accurateCalibrationResultsReady(Htt::AccurateCalibrationResults result);
    void calibrationGridValidationReady(QString result, map<string, bool> validation, vector<float> gridErrors);
    void accurateCalibrationValidationReady(QString result, map<string, bool> validation,
                                            Htt::LensFittingResults lensFittingResult);
    // Event generated by ImageViewerController used to save in the json file the screenshot png image
    void screenshotReady(QSharedPointer<QPixmap> img);
    // Event generated by ImageViewerController used to save in the json file the frame png image and a copy in
    // "config/images/" folder
    void frameReady(QSharedPointer<QPixmap> img);
    void itemChangedHttLightOutputFluxTable(QTableWidgetItem* item);
    void frameAvailable(QSharedPointer<HwData> data);
    void lensFittingResultReady(Htt::LensFittingResults res);
    void profileDetectionResultReady(Htt::ProfileDetectionResults res);
    // Event generated by ControlGroupBox used to change visualization state of the relative button
    void enableProgressNextButton(bool);
    // Event generated by ControlGroupBox in order to trigger a calibration procedure
    void startGridCalibrationRequired();
    void startAccurateCalibrationRequired(const double& deltaN, const double& H);

    void manualGrabRequired(QString filepath, QString filename);
    void detectProfileRequired(const double& deltaN, const double& H, QString modelType);

    void computeContrast(int x1, int y1, int x2, int y2);
    void removeSlicingResults();

    // FIXME: only for test!!!
    void pushButtonClickedSimulate(bool);

private:
    QStateMachine* m_sm;
    QWidget* m_startingSelectionWidget;
    QWidget* m_progressButtonsWidget;
    QGroupBox* m_stepsGroupBox;
    QGroupBox* m_instructionGroupBox;
    QGroupBox* m_outputGroupBox;
    QPushButton* m_startWizardButton;
    QPushButton* m_resumeWizardButton;
    QPushButton* m_progressNextButton;
    QPushButton* m_progressBackButton;
    QTextBrowser* m_userInstructionTextBrowser;
    QTextBrowser* m_outputResultsTextBrowser;
    QLabel* m_stepsLabel;
    QLabel* m_stepsComment;
    QLabel* m_statusLabel;

    QString step;

    QState* m_idle;
    QState* m_step1;
    QState* m_step2;
    QState* m_step3;
    QState* m_step4;
    QState* m_step5;
    QState* m_step6;
    QState* m_step7;
    QState* m_step8;
    QState* m_step9;
    QState* m_step10;
    QFinalState* m_done;

    ControlGroupBox* m_controlsGroupBox;
    GrabbingGroupBox* m_grabbingGroupBox;
    QWidget* m_ctrlCalibrationWidget;
    QSharedPointer<QImage> m_gridImage;
    QJsonObject m_calibrationJson;
    QLabel* m_validationTableTitle;
    QTableWidget* m_validationTableResults;
    QLabel* m_calibrationTableTitle;
    QTableWidget* m_calibrationTableResults;
    QJsonObject m_state;
    QJsonObject m_currentStep;
    bool m_progressBackButtonClicked;
    QTableWidget* m_httLightOutputFluxTable;
    QChart* m_httLightOutputFluxChart;
    QLineSeries* m_fluxSeries;
    QChartView* m_verticalContrastChart;
    QChartView* m_horizontalContrastChart;
    QTextBrowser* m_verticalConstrastText;
    QTextBrowser* m_horizontalConstrastText;

    shared_ptr<HwController> m_hwController;

    // FIXME: only for test!!!
    // QWidget* m_ctrlSimulateButton;
    // QSharedPointer<QImage> m_frameImage;
    QSharedPointer<HwData> m_frame;

    CalibationResumeTransition* m_resumeTransaction;
};

} // namespace UserApplication
} // namespace HTT
} // namespace Solution
} // namespace Nidek

#endif // __CALIBRATION_WIZARD_H__
